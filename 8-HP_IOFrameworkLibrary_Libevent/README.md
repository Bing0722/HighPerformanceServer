## 高性能I/O框架库Libevent

### I/O框架库概述
I/O框架库以库函数的形式，封装了较为底层的系统调用，给应用程序提供了一组更便于使用的接口。这些库函数往往比程序员自己实现的同样功能的函数更合理、更高效，且更健壮。因为它们经受住了真实网络环境下的高压测试，以及时间的考验。各种I/O框架库的实现原理基本相似，要么以Reactor模式实现，要么以Proactor模式实现，要么同时以这两种模式实现。举例来说，基于Reactor模式的I/O框架库包含
如下几个组件:**句柄(Handle)**、**事件多路分发器(EventDemultiplexer)**、**事件处理器(EventHandler)**和**具体的事件处理器(ConcreteEventHandler)**、**Reactor**

1. 句柄

I/O框架库要处理的对象，即I/O事件、信号和定时事件，统一称为事件源。一个事件源通常和一个句柄绑定在一起。句柄的作用是，当内核检测到就绪事件时，它将通过句柄来通知应用程序这一事件。在Linux环境下，I/O事件对应的句柄是文件描述符，信号事件对
应的句柄就是信号值。

2. 事件多路分发器

事件的到来是随机的、异步的。我们无法预知程序何时收到一个客户连接请求，又亦或收到一个暂停信号。所以程序需要循环地等待并处理事件，这就是事件循环。在事件循环中，等待事件一般使用I/O 复用技术来实现。I/O框架库一般将系统支持的各种I/O 复用系统
调用封装成统一的接口，称为事件多路分发器。事件多路分发器的`demultiplex`方法是等待事件的核心函数，其内部调用的是`select`、`poll`、`epoll_wait` 等函数。
此外，事件多路分发器还需要实现`register_event`和`remove_event`方法，以供调用者往事件多路分发器中添加事件和从事件多路分发器中删除事件。

3. 事件处理器和具体事件处理器

事件处理器执行事件对应的业务逻辑。它通常包含一个或多个`handle_event`回调函数,这些回调函数在事件循环中被执行。I/O框架库提供的事件处理器通常是一个接口，用户需要继承它来实现自己的事件处理器，即具体事件处理器。因此，事件处理器中的回调函数一般被声明为虚函数，以支持用户的扩展。
此外，事件处理器一般还提供一个`get_handle`方法，它返回与该事件处理器关联的句柄。那么，事件处理器和句柄有什么关系?当事件多路分发器检测到有事件发生时，它是通过句柄来通知应用程序的。因此，我们必须将事件处理器和句柄绑定，才能在事件发生时获取到正确的事件处理器。

4. Reactor

Reactor是I/O框架库的核心。它提供的几个主要方法是:
- `handle_events`。该方法执行事件循环。它重复如下过程:等待事件，然后依次处理所有就绪事件对应的事件处理器。
- `register_handler`。该方法调用事件多路分发器的`register_event`方法来往事件多路分发器中注册一个事件。
- `remove_handler`。该方法调用事件多路分发器的`remove_event`方法来删除事件多路分发器中的一个事件。